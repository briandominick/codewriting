= Resumé-as-Code
:page-layout: post
:page-permalink: blog-data-driven-static-resume
:page-date: 2019-01-08 18:22
:page-comments: true
:page-external-url:
:page-categories: [small-data]
:page-tags: [small data,Liquid,AsciiDoc,PDF,single sourcing,DRY]
:page-author: Brian Dominick
---

What better way to show off what I do as a software documentation platform developer (“DocOps engineer”) than by generating my own resumé with the technology stack I use professionally?
Prospective clients have remarked more that this gimmick caught their attention.
If you also earn a crust from setting up docs systems for engineering teams and the like, consider building your professional documentation from a single source to show off your skills.

With its singular source and dual link:https://www.codewriting.org/brian-dominick-resume[HTML] and link:https://www.codewriting.org/assets/files/brian-dominick-resume.pdf[PDF] output, my resumé is a simple model implementation of the AJYL docstack, consisting of AsciiDoc, Jekyll/JAMstack, YAML, and Liquid.

Here I will walk you through how I set it up, explaining how each component language and utility come into play.

== The Sources

These two output versions are sourced from the exact same files, so they are always in sync.
I don't have to remember to update two documents whenever I make a change.

Most of the specific content items are stored as _small data_ objects arranged in a link:https://idratherbewriting.com/documentation-theme-jekyll/mydoc_yaml_tutorial.html[YAML] file, with parameter values containing link:https://asciidoctor.org/docs/what-is-asciidoc/[AsciiDoc] markup.
That is, the stuff you might store in a database or at least a spreadsheet, I store in “flat” text files, similarly to how you have probably seen JSON or XML used.
YAML markup is simpler and easier to use than both these, however, since they were designed for machines to read.

Here is a YAML snippet drawn directly from the link:https://github.com/briandominick/codewriting/blob/master/data/dominick.yml[single-sourced file].

.From data/dominick.yml -- Resumé small data source file snippet
[source,yaml]
----
include::data/dominick.yml[tags="example-snippet"]
----

This is analogous to storing content objects as rows in a relational database, where the field contents would perhaps be plaintext characters _tagged_ with HTML or another brand of XML markup.
In our case, the datasource is a YAML data file, and the markup is lightweight AsciiDoc instead of tagged HTML/XML.
(Note the formatting of the linked text `pass:[https://www.ajyl.org/liquidoc-cmf[LiquiDoc CMF]]`, which in HTML would be all of `<a href="https://www.ajyl.org/liquidoc-cmf">LiquiDoc CMF</a>`.)

This data gets parsed with a link:https://github.com/Shopify/liquid/wiki[Liquid] template.
This template is designed to weave those AsciiDoc-formatted strings from the data file with more AsciiDoc markup.
The complete Liquid-formatted link:https://raw.githubusercontent.com/briandominick/codewriting/master/_templates/liquid/resume.asciidoc[source file] has the rest of the goods.

.From resume.asciidoc -- Template mixes Liquid with AsciiDoc, generates new AsciiDoc source
[source]
----
include::assets/includes/resume.asciidoc[tags="employment"]
----

Because Liquid templates are usually a mix of at least two markup languages (Liquid markup itself plus your target format), they can get pretty ugly.
Such is the nature of content templating.
Nevertheless, we can generate such elegant code this way.

Don't worry about the details of this code.
Basically what it does is loop through the `posts.paid` array in the data file, creating an entry for each item it comes across (objects describing my past paid gigs).
Then it expresses the details of that object, mixing it in with some AsciiDoc markup you'll also recognize in the output.

Since that final, prebuilt source is generated before this blog, I can also access the resulting file _in this blog post_.
(See the <<sniptip,tip admonition>> at the end of this post.)
This next snippet is drawn directly from the result of pressing our AsciiDoc-formatted small data with a AsciiDoc-oriented Liquid template to generate new AsciiDoc source.

.From _build/pages/resume.adoc -- AsciiDoc source file built by above procedure
[source,asciidoc]
----
include::pages/resume.adoc[tags="example-snippet"]
----

The above snippet includes just the AsciiDoc generated for the first two entries, though the `_built/pages/resume.adoc` file is a complete AsciiDoc document source.
(To see the whole file, you would have to clone and build the Codewriting repo, generating a copy into the `_build/pages/` directory.)

Finally, I render that AsciiDoc file as a PDF document using the killer link:http://prawnpdf.org/api-docs/2.0/[Prawn PDF utility], after which the link:https://jekyllrb.com/[Jekyll static site generator] spits it out as HTML.
Both of these processes invoke the link:https://github.com/asciidoctor/asciidoctor[Asciidoctor] rendering engine, as detailed below in <<the-build>>.

== The Output

Here are images from the relevant details from both rendered artifacts.

.HTML version
====
image::assets/images/screenshot-detail_resume-employment-html.png[]
====

.PDF version
====
image::assets/images/screenshot-detail_resume-employment-pdf.png[]
====

[[the-build]]
== The Build

Now that we see what happened, let's explore how it was _scripted_.

All of this activity is coordinated by link:https://www.ajyl.org/liquidoc[LiquiDoc], my free, open-source utility for combining AsciiDoc, YAML, and Liquid with Jekyll and other JAMstack services and utilities.
LiquiDoc is a nacent API for the AJYL docstack, designed for building rich-text documents in many editions and formats, all from the same source.

The Codewriting project's LiquiDoc link:https://github.com/briandominick/codewriting/blob/master/_configs/build-global.yml[configuration file (config)] for this site is pretty long, but essentially relevant three stages build both the HTML and PDF versions of the resumé.
Let's look at the first such stage.

.From _configs/build-global.yml -- LiquiDoc config file resume parsing stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="parse-resume-example-snippet"]
----

Here LiquiDoc is instructed to parse the `dominick.yml` data against the `resume.asciidoc` template, generating `resume.adoc`, an AsciiDoc source file containing Jekyll frontmatter.

.From _build/pages/resume.adoc -- Key Jekyll frontmatter params and content variables
[source,asciidoc]
----
include::pages/resume.adoc[tags="key-settings-jekyll"]
----

This file's header contains still more information for the PDF output.
When building the PDF version of the resumé, I override some of these variables (called _attributes_ in AsciiDoc parlance).

.From _build/pages/resume.adoc -- Key PDF parameters
[source,asciidoc]
----
include::pages/resume.adoc[tags="key-settings-pdf"]
----

Back to the config, the next stage instructs LiquiDoc to actually render the PDF version of the output from this prebuilt source file.

.From _configs/build-global.yml -- LiquiDoc config file resume PDF render stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="render-resume-example-snippet"]
----

This block invokes a very simple Asciidoctor conversion using the link:https://github.com/asciidoctor/asciidoctor-pdf[PDF backend extension], which engages Prawn for the final conversion.
A customized link:https://github.com/briandominick/codewriting/blob/master/theme/pdf/resume-theme.yml[YAML-formatted theme file] enforces the style of the PDF output.

The resulting PDF artifact will later be copied into the Jekyll-generated website, but first we have to perform that Jekyll generation.
The LiquiDoc config has us covered here, as well.

.From _configs/build-global.yml -- Jekyll build execution stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="build-jekyll-example-snippet"]
----

This section of the config script instructs Jekyll to generate a site, one page of which will be the HTML version of the resumé, as dictated by the `_build/pages/resume.adoc` file's frontmatter settings referenced above.
This conversion does not require a specific instruction, as Jekyll renders all files in `_build/pages/` by default, and this prebuil file is after all just another Jekyll-ready AsciiDoc file like link:https://github.com/briandominick/codewriting/tree/master/pages[all its siblings].

== Conclusion

These are all the main features of an AJYL platform: small data in YAML flat files, content in AsciiDoc, templating and transformation with Liquid, and Jekyll to put it all together as a proper website.

The rest of the Codewriting site uses similar techniques to massage data and content together, either during prebuilding with Liquid or when rendering final artifacts.
Asciidoctor uses parameters (AsciiDoc attributes) when converting AsciiDoc files to HTML, PDF, and other formats.
Also during the render build, Jekyll engages Liquid's template engine to construct the site's HTML (or even to link:https://github.com/asciidoctor/jekyll-asciidoc#enabling-liquid-preprocessing[preprocess AsciiDoc content files containing Liquid markup]).

While a resumé is merely a novel implementation of this varied and powerful technology stack, imagine what this kind of flexibility can do for conveying complex product data in numerous permutations of editions and output formats.

[#sniptip]
[TIP]
--
All of the snippets included in this blog entry are derived from the original source.
This blog is sourced in AsciiDoc, enabling dynamic embedding (_inclusion_) of content from the codebase itself.
For instance, look at the source that renders the final code listing above.

[source,asciidoc]
--------
.From _configs/build-global.yml -- Jekyll build execution stage
[source,yaml]
----
\include::assets/includes/build-global.yml[tags="build-jekyll-example-snippet"]
----
--------

The file `build-global.yml` is tagged with comments indicating what to snip when this line is called.
--
