= Static Content Derived from Small Data
:page-layout: post
:page-permalink: blog-data-driven-static-resume
:page-date: 2019-01-08 18:22
:page-comments: true
:page-external-url:
:page-categories: [small-data]
:page-tags: [small data,Liquid,AsciiDoc,PDF,single sourcing,DRY]
:page-author: Brian Dominick
---

I've done something weird with a very common document most people prefer not to fuss with.
Really just as a demonstration of the power of an AJYL toolchain--employing AsciiDoc, JAMstack/Jekyll, YAML, and Liquid--my professional resumé is generated along with link:https://www.codewriting.org[codewriting.org] and the _Codewriting_ book when performing a complete build of the repo that generates this very site.

Now, if you are not expressly trying to prove you know clever ways to generate disparate output from a common source to earn a crust, this may well be overkill for you.
Nevertheless, allow me to use it as an example of what can be done with a docs-as-code platform.
First, take a quick look at my resumé in link:https://www.codewriting.org/brian-dominick-resume[HTML] as well as the link:https://www.codewriting.org/assets/files/brian-dominick-resume.pdf[PDF].
The content doesn't matter much, just note that it's largely the same matter with some variance between the HTML and PDF versions, derived from DRY (don't repeat yourself) source.

== The Sources

I source most of the specific content items as _small data_ objects arranged in a link:https://idratherbewriting.com/documentation-theme-jekyll/mydoc_yaml_tutorial.html[YAML] file, with parameter values containing AsciiDoc markup.
That is, what I call small data is stored in text files (“flat files”), similarly to how you have probably seen JSON or XML stored, only the markup is simpler and easier than either.

Here is a snippet drawn directly from the link:https://github.com/briandominick/codewriting/blob/master/data/dominick.yml[single-sourced file] in the popular YAML format.

.From data/dominick.yml -- Resumé small data source file snippet
[source,yaml]
----
include::data/dominick.yml[tags="example-snippet"]
----

This is analogous to storing HTML/XML-formatted content objects as rows in a relational database, where the field contents would perhaps be plaintext characters _tagged_ with XML-style markup.
In our case, the datasource is a YAML data file, and the markup is lightweight AsciiDoc instead of tagged HTML/XML.
(Note the formatting of the linked text `pass:[https://www.ajyl.org/liquidoc-cmf[LiquiDoc CMF]]`, which in HTML would be all of `<a href="https://www.ajyl.org/liquidoc-cmf">LiquiDoc CMF</a>`.)

This data gets parsed by a link:https://shopify.github.io/liquid/[Liquid template] written to intermingle the AsciiDoc-formatted strings from the data file with more AssciiDoc markup, including some of the AsciiDoc-formatted content featured between the various lists that make up my resumé.
The complete Liquid-formatted link:https://raw.githubusercontent.com/briandominick/codewriting/master/_templates/liquid/resume.asciidoc[source file] has the rest of the goods.

.From resume.asciidoc -- Template mixes Liquid with AsciiDoc, generates new AsciiDoc source
[source]
----
include::assets/includes/resume.asciidoc[tags="employment"]
----

Because Liquid templates are usually a mix of at least two markup languages (Liquid markup itself plus your target format), they can get pretty ugly.
Such is the nature of content templating.
Nevertheless, we can generate such elegant code this way.

Don't worry about the details of this code.
Basically what it does is loop through the `posts.paid` array in the data file, creating an entry for each item it comes across (objects describing my past paid gigs).
Then it expresses the details of that object, mixing it in with some AsciiDoc markup you'll also recognize in the output.

Since that final, prebuilt source is generated before this blog, I can also access the resulting file _in this blog post_.
(See the <<sniptip,tip admonition>> at the end of this post.)
This next snippet is drawn directly from the result of pressing our AsciiDoc-formatted small data with a AsciiDoc-oriented Liquid template to generate new AsciiDoc source.

.From _build/pages/resume.adoc -- AsciiDoc source file built by above procedure
[source,asciidoc]
----
include::pages/resume.adoc[tags="example-snippet"]
----

The above snippet includes just the AsciiDoc generated for the first two entries, though the `pages/resume.adoc` file is a complete AsciiDoc document source.
(To see the whole file, you would have to clone and build the Codewriting repo, generating a copy into the `_build/pages/` directory.)

Finally, I render that AsciiDoc file through Asciidoctor and build it into a page with link:https://jekyllrb.com/[Jekyll static-site generator], as well as a PDF document using the killer link:http://prawnpdf.org/api-docs/2.0/[Prawn PDF utility].

== The Output

Here are images from the relevant details from both rendered artifacts.

.HTML version
====
image::assets/images/screenshot-detail_resume-employment-html.png[]
====

.PDF version
====
image::assets/images/screenshot-detail_resume-employment-pdf.png[]
====

== The Build

Now that we see what happened, let's explore how it was _scripted_.

All of this activity is coordinated by link:https://www.ajyl.org/liquidoc[LiquiDoc], my free, open-source utility for combining AsciiDoc, YAML, and Liquid to build rich-text documents in many editions and formats, all from the same source.
The Codewriting project's LiquiDoc link:https://github.com/briandominick/codewriting/blob/master/_configs/build-global.yml[configuration file (config)] for this site is pretty long, but essentially three stages build both the HTML and PDF versions.
Let's look at the first such stage.

.From _configs/build-global.yml -- LiquiDoc config file resume parsing stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="parse-resume-example-snippet"]
----

Here LiquiDoc is instructed to parse the `dominick.yml` data against the `resume.asciidoc` template, generating `resume.adoc`, an AsciiDoc source file containing Jekyll frontmatter.

.From pages/resume.adoc -- Key Jekyll frontmatter params and content variables
[source,asciidoc]
----
include::pages/resume.adoc[tags="key-settings-jekyll"]
----

This file's header contains still more information for the PDF output.
When building the PDF version of the resumé, I override some of these variables (called _attributes_ in AsciiDoc parlance).

.From _build/pages/resume.adoc -- Key PDF parameters
[source,asciidoc]
----
include::pages/resume.adoc[tags="key-settings-pdf"]
----

Back to the config, the next stage instructs LiquiDoc to actually render the PDF version of the output from this prebuilt source file.

.From _configs/build-global.yml -- LiquiDoc config file resume PDF render stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="render-resume-example-snippet"]
----

This block invokes a very simple Asciidoctor conversion using the Prawn-integrating link:https://github.com/asciidoctor/asciidoctor-pdf[PDF backend extension].

The resulting PDF artifact will later be copied into the Jekyll-generated website, but first we have to perform that Jekyll generation.
The LiquiDoc config has us covered here, as well.

.From _configs/build-global.yml -- Jekyll build execution stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="build-jekyll-example-snippet"]
----

This section of the config script instructs Jekyll to generate a site, one page of which will be the HTML version of the resumé, as dictated by the `_build/pages/resume.adoc` file's frontmatter settings referenced above.
This conversion does not require a specific instruction, as Jekyll renders all files in `_build/pages/` by default, and this prebuil file is after all just another Jekyll-ready AsciiDoc file like link:https://github.com/briandominick/codewriting/tree/master/pages[all its siblings].

== Conclusion

These are all the main features of an AJYL platform: small data in YAML flat files, content in AsciiDoc, templating and transformation with Liquid, and Jekyll to pull it all together.

The rest of the Codewriting site uses similar techniques to massage data and content together, either during prebuilding with Liquid or when rendering final artifacts.
Asciidoctor uses parameters (AsciiDoc attributes) when converting AsciiDoc files to HTML, PDF, and other formats.
Also during the render build, Jekyll engages Liquid's template engine to construct the site's HTML (or even to link:https://github.com/asciidoctor/jekyll-asciidoc#enabling-liquid-preprocessing[preprocess AsciiDoc content files containing Liquid markup]).

While a resumé is surely a novel implementation of this complex and powerful technology stack, imagine what this kind of flexibility can do for conveying complex product data in numerous permutations of editions and output formats.

[#sniptip]
[TIP]
--
All of the snippets included in this blog entry are derived from the original source.
This blog is sourced in AsciiDoc, enabling dynamic inclusion of content from the codebase itself.
For instance, look at the code that renders the final code listing above.

[source,asciidoc]
--------
.From _configs/build-global.yml -- Jekyll build execution stage
[source,yaml]
----
\include::assets/includes/build-global.yml[tags="build-jekyll-example-snippet"]
----
--------
--
