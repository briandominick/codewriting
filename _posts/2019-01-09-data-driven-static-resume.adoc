= Resumé-as-Code: Small Data Sourcing for Fun & Profit
:page-layout: post
:page-permalink: blog-small-data-driven-resume
:page-date: 2019-01-09 19:22
:page-comments: true
:page-external-url:
:page-categories: [small-data]
:page-tags: [small data,Liquid,AsciiDoc,PDF,single sourcing,DRY]
:page-author: Brian Dominick
:toc: macro

What better way to show off what I do as a documentation platform developer (“DocOps engineer”) than by generating my own resumé with the technology stack I use professionally?
Several prospective clients have remarked on the demonstrative novelty of this approach.
If you also earn a crust from setting up documentation environments for engineering teams and the like, consider building your professional documentation from code to show off your skills.

With its singular source and dual link:https://www.codewriting.org/brian-dominick-resume[HTML] and link:https://www.codewriting.org/assets/files/brian-dominick-resume.pdf[PDF] output, my resumé is a microcosmic model implementation of the AJYL tech stack, consisting of *AsciiDoc*, *Jekyll*/*JAMstack*, *YAML*, and *Liquid*.

In this post, I will walk you through how I set it all up, explaining how each component language and utility come into play.

toc::[]

== The Sources

Most of the specific content items in my resumé are stored as _small data_ objects arranged in a link:https://idratherbewriting.com/documentation-theme-jekyll/mydoc_yaml_tutorial.html[YAML] file, similar to fields in a database.
A small-data file is simply a plaintext document made up of keys and values structured such that both people and machines can modify and consume the organized information.

Here is a YAML snippet drawn directly from the link:https://github.com/briandominick/codewriting/blob/master/data/dominick.yml[single-sourced file].

.From data/dominick.yml -- Resumé small data source file snippet
[source,yaml]
----
include::data/dominick.yml[tags="example-snippet"]
----

If you inspect the link:https://github.com/briandominick/codewriting/blob/master/data/dominick.yml[whole file], you will see it contains several clusters of data, each analogous to a table in a database.

[TIP]
One advantage of maintaining small data in flat files is that you can build an entire, perfectly portable datasource with a text editor in mere minutes.

In this case, parameter values contain link:https://asciidoctor.org/docs/what-is-asciidoc/[AsciiDoc] markup.
Notice on the first line beginning with a `destination:` key, the value text contains AsciiDoc hyperlink markup.

This data gets parsed with a link:https://github.com/Shopify/liquid/wiki[Liquid] template.
This particular Liquid template (link:https://raw.githubusercontent.com/briandominick/codewriting/master/_templates/liquid/resume.asciidoc[see complete source]) weaves those AsciiDoc-formatted strings from the data file with more AsciiDoc markup.

.From resume.asciidoc -- Template mixes Liquid with AsciiDoc, generates new AsciiDoc source
[source]
----
include::assets/includes/resume.asciidoc[tags="employment"]
----

Because Liquid templates are usually a mix of at least two markup languages (Liquid markup itself plus your target format), they can feel pretty busy.
Such is the nature of content templating.
Nevertheless, we can generate such elegant code this way.

Don't worry about the details of this code.
Basically what it does is iterate (“loop”) through the `posts.paid` array in the data file, creating an entry for each item it comes across (objects describing my past paid gigs).
As it churns, Liquid expresses the details of each object, mixing it in with some AsciiDoc markup you'll also recognize in the output just below.

.From _build/pages/resume.adoc -- AsciiDoc source file output after parsing
[source,asciidoc]
----
include::pages/resume.adoc[tags="example-snippet"]
----

The above snippet includes just the AsciiDoc generated for the first two entries, though the `_build/pages/resume.adoc` file is a complete AsciiDoc document source.

[NOTE]
Since this file is built and thus not tracked in the Git repository, to see the whole file you would have to clone and build the Codewriting repo, generating a copy into the `_build/pages/` directory.)

[TIP]
Because that final, prebuilt source is generated before this blog, the above snippet is directly sourced from the resulting file, accessed while this blog post was being rendered and ensuring it always accurately reflects the _current_ state of the underlying data.
(See the <<sniptip,bonus explainer>> at the end of this post.)

Finally, I render that AsciiDoc file into rich-text output.
The PDF document is generated by the killer link:http://prawnpdf.org/api-docs/2.0/[*Prawn* PDF utility], after which the link:https://jekyllrb.com/[Jekyll static site generator] spits it out as HTML.
Both of these processes invoke the link:https://github.com/asciidoctor/asciidoctor[*Asciidoctor*] rendering engine, as detailed below in <<the-build>>.

== The Output

Here are images from the relevant details of both rendered artifacts.

.HTML version
====
image::assets/images/screenshot-detail_resume-employment-html.png[]
====

.PDF version
====
image::assets/images/screenshot-detail_resume-employment-pdf.png[]
====

[[the-build]]
== The Build

Now that we see what happened, let's explore how it was _scripted_.

All of this activity is coordinated by link:https://www.ajyl.org/liquidoc[*LiquiDoc*], my free, open-source utility for combining AsciiDoc, YAML, and Liquid with Jekyll and other link:https://jamstack.org/[JAMstack services and utilities].
LiquiDoc is a nascent API for the AJYL docstack, designed for building rich-text documents in many editions and formats, all from the same source, by invoking upstream tools (such as Asciidoctor, Liquid, and Jekyll processing engines).

The Codewriting project's LiquiDoc link:https://github.com/briandominick/codewriting/blob/master/_configs/build-global.yml[build configuration file (config)] for this site is pretty long, but essentially three relevant stages generate both the HTML and PDF versions of the resumé.
Let's look at the first stage.

.From _configs/build-global.yml -- LiquiDoc config file resume parsing stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="parse-resume-example-snippet"]
----

Here LiquiDoc is instructed to parse the `dominick.yml` data with the `resume.asciidoc` template.
This generates `resume.adoc`, an AsciiDoc source file containing its own output instructions, saved to the ephemeral `_build/pages/` directory.

Whenever the `resume.adoc` file is processed by Asciidoctor, header information (“frontmatter” in Jekyll parlance) designates the output settings and variables.
First, it establishes settings and default variables, which will be used in the Jekyll site generation.

.From _build/pages/resume.adoc -- Key Jekyll frontmatter settings and content variables
[source,asciidoc]
----
include::pages/resume.adoc[tags="key-settings-jekyll"]
----

This built file's header also contains information for the PDF rendering.

.From _build/pages/resume.adoc -- Key PDF settings and content variables
[source,asciidoc]
----
\ifdef::backend-pdf[]
include::pages/resume.adoc[tags="key-settings-pdf"]
\endif::backend-pdf[]
----

The first and last lines are conditionals; they ensure the enveloped settings are only applied during rendering procedures if the `backend-pdf` setting (“attribute” in AsciiDoc parlance) is defined.
These will replace any previously set parameters with the same names.

Which gets us back to the LiquiDoc config.
The next stage instructs LiquiDoc to actually render the PDF version of the output from the source file prebuilt in the last stage (`_build/pages/resume.adoc`).

.From _configs/build-global.yml -- LiquiDoc config file resume PDF render stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="render-resume-example-snippet"]
----

This block invokes a very simple Asciidoctor conversion using the link:https://github.com/asciidoctor/asciidoctor-pdf[PDF backend extension], which engages Prawn for the final conversion.
A customized link:https://github.com/briandominick/codewriting/blob/master/theme/pdf/resume-theme.yml[YAML-formatted theme file] enforces the style of the PDF output.

The resulting PDF artifact will later be copied into the Jekyll-generated website so it can be served, but first we have to build the rest of the site, including the HTML version of the resumé.
LiquiDoc has us covered here, as well.

[[example-config-jekyll]]
.From _configs/build-global.yml -- Jekyll build execution stage
[source,yaml]
----
include::assets/includes/build-global.yml[tags="build-jekyll-example-snippet"]
----

This section of the config script instructs Jekyll to generate a site, one page of which will be the HTML version of the resumé, as dictated by the `_build/pages/resume.adoc` file's frontmatter settings referenced above.
This conversion does not require a specific instruction, as Jekyll renders all files in `_build/pages/` by default, and this prebuilt file is after all just another Jekyll-ready AsciiDoc file like link:https://github.com/briandominick/codewriting/tree/master/pages[all its siblings].

After the static site is built, LiquiDoc copies the PDF resumé into it, and the whole thing is ready to be served.

== Conclusion

These are all the main features of an AJYL platform: small data in YAML flat files, content in AsciiDoc, templating and transformation with Liquid, and Jekyll to put it all together as a proper website.

The rest of the Codewriting site uses similar techniques to massage data and content together, either during prebuilding with Liquid or when rendering final artifacts.
Asciidoctor uses parameters (AsciiDoc attributes) when converting AsciiDoc files to HTML, PDF, and other formats.
Also during the render build, Jekyll engages Liquid's template engine to construct the site's HTML (or even to link:https://github.com/asciidoctor/jekyll-asciidoc#enabling-liquid-preprocessing[preprocess AsciiDoc content files containing Liquid markup]).
All this complementarity is key to the AJYL environment.

While a resumé is merely a novel implementation of this varied and powerful technology stack, imagine what this kind of flexibility can do for conveying complex product data in numerous permutations of editions and output formats.

[[sniptip]]
== Meta: How this Post was Made

All of the snippets included in this blog entry are derived from the original source.
The link:https://www.codewriting.org/blog[Code the Docs blog] is sourced in AsciiDoc, enabling dynamic embedding (“inclusion”) of content from the codebase itself.

For instance, look at the source that renders the final code listing above (<<example-config-jekyll>>).

.From the AsciiDoc source for this blog entry
[source,asciidoc]
--------
.From _configs/build-global.yml -- Jekyll build execution stage
[source,yaml]
----
\include::assets/includes/build-global.yml[tags="build-jekyll-example-snippet"]
----
--------

The link:https://github.com/briandominick/codewriting/blob/master/_configs/build-global.yml[original config file] (`_configs/build-global.yml`) is tagged with comment code indicating what to snip for inclusion into another file.
(This file is copied into the ephemeral build directory to make it available in this way, hence we are technically reading from a clone saved to `_build/assets/includes/` early in the build procedure.)
In the blog post source, the AsciiDoc `include::` macro includes a request for the section of code tagged `build-jekyll-example-snippet`.

Note the advantage over conventional blogging, which entails copying and pasting source code samples into a post that gets saved in a database (and forgotten).
Once you've duplicated the source, it becomes a divergence risk; unless you update any docs referencing it, they will be inaccurate.
How many bloggers do you know who update code samples in years-old posts to ensure they stay current?
(Not me, I must admit.)

I will add that this system came in handy throughout the _writing_ of this post, during which I manipulated each source multiple times in order to arrange good example snippets.

Imagine if your user docs always reflected current code examples and other canonical information, drawn straight from the product source.
